#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# Copyright (C) 2019 Nathanael Philipp (jnphilipp) <nathanael@philipp.land>
"""Encrypt/Decrypt GPG/MIME emails.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program. If not, see <http://www.gnu.org/licenses/>.
"""
"""This tool can encrypt and decrypt emails using PGP/MIME. Emails inputed from
stdin and outputed to stdout. When encrypting, the tool preserves all headers
in the original email in the encrypted part, and copies relevant headers to the
output. When decrypting, any headers are ignored, and only the encrypted
headers are restored.

Encrypted email are not reencrypted. This is check based on the content type.
"""

import sys

from argparse import ArgumentParser, RawTextHelpFormatter, ArgumentTypeError
from email import message_from_file
from email.encoders import encode_7or8bit
from email.message import Message
from email.mime.base import MIMEBase
from email.mime.application import MIMEApplication
from email.mime.multipart import MIMEMultipart
from gnupg import GPG
from math import ceil, floor
from typing import List


__author__ = 'Nathanael Philipp'
__email__ = 'nathanael@philipp.land'
__license__ = 'GPLv3'
__version__ = '0.3.2'
__github__ = 'https://github.com/jnphilipp/gpgmail'
version = f'%(prog)s v{__version__}\n\nReport bugs to {__github__}/issues.' + \
    f'\n\nWritten by {__author__} <{__email__}>'
PROTECTED_HEADERS = {'CC', 'Date', 'Followup-To', 'From', 'Message-ID',
                     'Newsgroups', 'References', 'Reply-To', 'Subject', 'To'}


def copy_headers(source: Message, target: Message) -> Message:
    headers_not_to_override = {key.lower() for key in target.keys()}
    for key, value in source.items():
        if key.lower() not in headers_not_to_override:
            target[key] = value
    return target


def encrypt(mail: Message, recipients: List[str], encrypt_subject: bool=True,
            gnupghome: str=None) -> str:
    """Encrypt the given mail"""
    if 'protected-headers="v1"' not in mail['Content-Type']:
        base_msg = MIMEBase(_maintype='multipart', _subtype='mixed',
                            protected_headers='v1')

        pheaders_msg = Message()
        pheaders_msg.add_header(_name='Content-Type',
                                 _value='text/rfc822-headers',
                                 protected_headers='v1')
        pheaders_msg.add_header(_name='Content-Disposition', _value='inline')

        keys = {k.lower() for k in mail.keys()}
        for k in PROTECTED_HEADERS:
            if k.lower() in keys:
                pheaders_msg.add_header(_name=k, _value=mail[k])

        orig_msg = Message()
        orig_msg['Content-Type'] = mail['Content-Type']
        orig_msg.set_payload(mail.get_payload())

        base_msg.attach(pheaders_msg)
        base_msg.attach(orig_msg)
        mail = copy_headers(mail, base_msg)

    encrypted = GPG(gnupghome=gnupghome).encrypt(mail.as_string(), recipients)
    if not encrypted.ok:
        sys.stderr.write(encrypted.status)
        return mail.as_string()

    pgp_msg = MIMEBase(_maintype='multipart', _subtype='encrypted',
                       protocol='application/pgp-encrypted')
    if encrypt_subject:
        pgp_msg.add_header(_name='Subject', _value='...')

    pgp_msg_part1 = Message()
    pgp_msg_part1.add_header(_name='Content-Type',
                             _value='application/pgp-encrypted')
    pgp_msg_part1.add_header(_name='Content-Description',
                             _value='PGP/MIME version identification')
    pgp_msg_part1.set_payload('Version: 1\n')

    pgp_msg_part2 = Message()
    pgp_msg_part2.add_header(_name='Content-Type',
                             _value='application/octet-stream',
                             name='encrypted.asc')
    pgp_msg_part2.add_header(_name='Content-Description',
                             _value='OpenPGP encrypted message')
    pgp_msg_part2.add_header(_name='Content-Disposition',
                             _value='inline', filename='encrypted.asc')
    pgp_msg_part2.set_payload(str(encrypted))

    pgp_msg.attach(pgp_msg_part1)
    pgp_msg.attach(pgp_msg_part2)
    return copy_headers(mail, pgp_msg).as_string()


def decrypt(mail: Message, gnupghome: str=None) -> str:
    """Decrypt the given mail"""
    decrypted = GPG(gnupghome=gnupghome).decrypt(mail.as_string())
    if not decrypted.ok:
        sys.stderr.write(decrypted.status)
        return mail.as_string()
    return str(decrypted)


if __name__ == '__main__':
    parser = ArgumentParser(prog='gpgmail',
                            formatter_class=RawTextHelpFormatter)
    parser.add_argument('-v', '--version', action='version', version=version)
    parser.add_argument('-S', '--encrypt-subject', action='store_true',
                        help='Encrypt the subject when encrypting a email.')
    parser.add_argument('RECIPIENTS', nargs='*',
                        help='Key id or email of keys to encrypt for')

    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument('-e', '--encrypt', action='store_true',
                       help='Encrypt email from stdin to stdout.')
    group.add_argument('-d', '--decrypt', action='store_true',
                       help='Decrypt email from stdin to stdout.')

    parser.add_argument('--gnupghome', default=None,
                        help='Path to GnuPG home dir.')
    args = parser.parse_args()

    mail = message_from_file(sys.stdin)
    if args.encrypt:
        if mail.get_content_type() == 'multipart/encrypted':
            sys.stdout.write(mail.as_string())
        else:
            sys.stdout.write(encrypt(mail, args.RECIPIENTS,
                                     args.encrypt_subject, args.gnupghome))
    elif args.decrypt:
        sys.stdout.write(decrypt(mail, args.gnupghome))
